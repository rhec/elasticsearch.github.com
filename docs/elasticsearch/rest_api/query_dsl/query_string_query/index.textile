---
layout: doc_es
title: ElasticSearch Docs | REST Query DSL API | Query String Query
---

<script type="text/javascript">
docBreadcrumb = [
    ["elasticsearch", "ElasticSearch"], 
    ["rest_api", "REST API"],
    ["query_dsl", "Query DSL"],
    ["query_string_query", "Query String Query"],
];
</script>

h1. Query String Query

p. A query that uses a query parser in order to parse its content. Here is an example:

<pre class="prettyprint lang-js">
{
    "query_string" : { 
        "default_field" : "content", 
        "query" : "this AND that OR thus"
    }
}
</pre>

p. The @query_string@ top level parameters include:

|_. Parameter |_. Description |
| @query@ | The actual query to be parsed. |
| @default_field@ | The default field for query terms if no prefix field is specified. Defaults to the @_all@ field. |
| @default_operator@ | The default operator used if no explicit operator is specified. For example, with a default operator of @OR@, the query @capital of Hungary@ is translated to @capital OR of OR Hungary@, and with default operator of @AND@, the same query is translated to @capital AND of AND Hungary@. The default value is @OR@. |
| @analyzer@ | The analyzer name used to analyze the query string. |
| @allow_leading_wildcard@ | When set, @*@ or @?@ are allowed as the first character. Defaults to @true@. |
| @lowercase_expanded_terms@ | Whether terms of wildcard, prefix, fuzzy, and range queries are to be automatically lower-cased or not (since they are not analyzed). Default it @true@. |
| @enable_position_increments@ | Set to @true@ to enable position increments in result queries. Defaults to @true@. |
| @fuzzy_prefix_length@ | Set the prefix length for fuzzy queries. Default is @0@. |
| @fuzzy_min_sim@ | Set the minimum similarity for fuzzy queries. Defaults to @0.5@ |
| @phrase_slop@ | Sets the default slop for phrases. If zero, then exact phrase matches are required.  Default value is @0@.|
| @boost@ | Sets the boost value of the query. Defaults to @1.0@. |

h2. Multi Field

p. The @query_string@ query can also run against multiple fields. The idea of running the @query_string@ query against multiple fields is by internally creating several queries for the same query string, each with @default_field@ that match the fields provided. Since several queries are generated, combining them can be automatically done either using a @dis_max@ query or a simple @bool@ query. For example (the @name@ is boosted by 5 using @^5@ notation):

<pre class="prettyprint lang-js">
{
    "query_string" : { 
        "fields" : ["content", "name^5"], 
        "query" : "this AND that OR thus",
        "use_dis_max" : true
    }
}
</pre>

p. When running the @query_string@ query against multiple fields, the following additional parameters are allowed:

|_. Parameter |_. Description |
| @use_dis_max@ | Should the queries be combined using @dis_max@ (set it to @true@), or a @bool@ query (set it to @false@). Defaults to @true@.|
| @tie_breaker@ | When using @dis_max@, the disjunction max tie breaker. Defaults to @0@. |

p. The fields parameter can also include pattern based field names, allowing to automatically expand to the relevant fields (dynamically introduced fields included). For example:

<pre class="prettyprint lang-js">
{
    "query_string" : { 
        "fields" : ["content", "name.*^5"], 
        "query" : "this AND that OR thus",
        "use_dis_max" : true
    }
}
</pre>

h2. Syntax Extension

p. There are several syntax extensions to the Lucene query language.

h3. missing / exists

p. The @_exists_@ and @_missing_@ syntax allows to control docs that have fields that exists within them (have a value) and missing. The syntax is: @_exists_:field1@, @_missing_:field@ and can be used anywhere a query string is used.
